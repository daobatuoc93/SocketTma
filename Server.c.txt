#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include <errno.h>
#include <semaphore.h>
/*
    Implement code
*/
sem_t bin_sem;
pthread_cond_t thread_flag_cv;
pthread_mutex_t thread_flag_mutex;
char *get_IP(char *DATA_from_client)
{
    char *a = DATA_from_client + '\0';
    int temp = 0;
    int i, flag = 0;
    char *Ip;
    Ip = malloc((1023) * sizeof(char)); //Data return will < 1kB;if message >1kB,set again plz.
    for (i = 0; i < strlen(a); i++)
    {
        if (a[i] == '\"')
        {
            temp++;
            if (temp == 4)
            {
                memcpy(Ip, &a[flag + 1], i - flag - 1);
                break;
            }
            flag = i;
        }
    }
    return Ip;
}
char *get_DATA(char *DATA_from_client)
{

    char *a = DATA_from_client + '\0';
    int temp = 0;
    int i, flag = 0;
    char *DATA; //Data return will < 1kB;if message >1kB,set again plz.
    DATA = malloc(1024 * sizeof(char));
    for (i = 0; i < strlen(a); i++)
    {
        if (a[i] == '\"')
        {
            temp++;
            if (temp == 8)
            {
                memcpy(DATA, &a[flag + 1], i - flag - 1);
                break;
            }
            flag = i;
        }
    }
    return DATA;
}

typedef struct
{
    int sock;
    char username[30];
    struct sockaddr_in address_client;
    socklen_t socksize;
}connection_t;
struct Node
{
    connection_t *client;
    struct Node *next;
};

struct Node *head = NULL;
struct Node *current = NULL;

//display the list
void printList()
{
    struct Node *ptr = head;
    printf("\nClient list:\r\n");

    //start from the beginning
    while (ptr != NULL)
    {
        printf("\t[Socket:%d with IP username:%s]\n", ptr->client->sock, ptr->client->username); //inet_ntoa(ptr->client->address_client.sin_addr)
        ptr = ptr->next;
    }
}
bool isEmpty()
{
    return head == NULL;
}
int length()
{
    int length = 0;
    struct Node *current;

    for (current = head; current != NULL; current = current->next)
    {
        length++;
    }

    return length;
}
void insertFirst(connection_t *client)
{
    //create a link
    struct Node *link = (struct Node *)malloc(sizeof(struct Node));

    link->client = client;
    
    //point it to old first node
    link->next = head;

    //point first to new first node
    head = link;
    
}
void *process(void *ptr)
{
    struct Node *listClient = head;

    while (1)
    {
        char buffer[1024];
        int len;
        connection_t *conn, *newclient;

        long addr = 0;

        if (!ptr)
            pthread_exit(0);
        conn = (connection_t *)ptr;

        /* read length of message */
        int recv_size = recv(conn->sock, buffer, 1024, 0);
        char *getData = get_DATA(buffer);
        char *to_IP = get_IP(buffer);
        if (recv_size > 0)
        {
            //addr = (long)((struct sockaddr_in*)&conn->address)->sin_addr.s_addr;
            printf("\nDATA: %s", getData);
            printf("\nTo IP: %s", to_IP);
            while (listClient != NULL)
            {
                if(write(listClient->client->sock, getData, sizeof(getData))<0){
                    printf("\nsent nOK!");
                }
                listClient = listClient->next;
            }

            /* Continue to configure*/
            /////////////////////////////////////////////////////////////////////////
            int respond = send(conn->sock, getData, strlen(getData), 0);
            if (respond > 0)
            {
                printf("\nsent OK!");
            }
            else
            {
                printf("\nsent nOK!");
            }
        }
        /* close socket and clean up
        close(conn->sock);
        free(conn);
        pthread_exit(0);
        */
    }
}
void *waitClientAddusername(void *ptr)
{
    connection_t *newAddr = (connection_t *)ptr;
    char usernamerecv[30];
    int n,i=5;
    memset(usernamerecv, 0, 30);

    n = read(newAddr->sock, usernamerecv, 30);
    if (n < 0)
    {
        error("ERROR reading from client ");
    }
    else
    {
        printf("User [%s] is connected!\n", usernamerecv);
        strcpy(newAddr->username, usernamerecv);
    }
    printf("Connection accepted with client username: %s\n", newAddr->username);
    //Add information's data to database
    insertFirst(ptr);
    sem_post(&bin_sem);
    // while (i > -1)
    //         { // 10 second countdown
    //             printf("\033[A\33[2K\t Thread will exit after %d...\n", i);
    //             i--;
    //             sleep(1);
    //         }
    pthread_exit(NULL);
}
int main(int argc, char **argv)
{

    char sendbuff[256];
    int sockfd, ret, port, res, i = 3;
    void *thread_result;
    connection_t serverAddr;
    connection_t *newAddr = (connection_t *)malloc(sizeof(connection_t));
    pthread_t thread_waitusername, thread;
    int newSocket;
    res = sem_init(&bin_sem, 0, 0);
    if (res != 0)
    {
        perror("Semaphore initialization failed");
        exit(EXIT_FAILURE);
    }
    socklen_t addr_size;

    char buffer[1024];
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s port\n", argv[0]);
        return -1;
    }
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
    {
        printf("[-]Error in connection.\n");
        exit(1);
    }
    printf("[+]Server Socket is created.\n");
    if (sscanf(argv[1], "%d", &port) <= 0)
    {
        fprintf(stderr, "%s: error: wrong parameter: port\n", argv[0]);
        return -2;
    }
    memset(&serverAddr, '\0', sizeof(serverAddr));
    serverAddr.address_client.sin_family = AF_INET;
    serverAddr.address_client.sin_port = htons(port);
    serverAddr.address_client.sin_addr.s_addr = INADDR_ANY;

    ret = bind(sockfd, (struct sockaddr *)&serverAddr.address_client, sizeof(struct sockaddr_in));
    if (ret < 0)
    {
        printf("[-]Error in binding.\n");
        exit(1);
    }
    printf("[+]Bind to port %d\n", port);

    if (listen(sockfd, 5) == 0)
    {
        printf("[+]Listening....\n");
    }
    else
    {
        printf("[-]Error in binding.\n");
    }

    while (1)
    {
        newSocket = accept(sockfd, (struct sockaddr *)&newAddr->address_client, (socklen_t *)&addr_size);

        if (newSocket < 0)
        {
            printf("Connection has been disconnected!\n");
            exit(1);
        }
        else
        {
            /*waiting for client sent username  
                threads handle to receive username*/
            printf("Create thread waits username from client!\n");
            newAddr->sock = newSocket;
            printf("newAddr->sock = %d \n", newAddr->sock);
            res = pthread_create(&thread_waitusername, NULL, waitClientAddusername, (void *)newAddr);
            if (res != 0)
            {
                perror("Thread creation failed");
                exit(EXIT_FAILURE);
            }
            else
                printf("create Ok!\n");
            sem_wait(&bin_sem);
            //printf("Connection accepted from %s:%d\n", inet_ntoa(newAddr->address_client.sin_addr), ntohs(newAddr->address_client.sin_port));
           
            //            printList();
            //
            pthread_create(&thread, 0, process, (void *)newAddr);
            //            pthread_detach(thread);
            res = pthread_join(thread_waitusername, &thread_result);
            if (res != 0)
            {
                perror("Thread join failed");
                exit(EXIT_FAILURE);
            }
            printf("Thread joined\n");
            sem_destroy(&bin_sem);
            printList();
            printf("Waiting for new client connect ...\n");
//           exit(EXIT_SUCCESS);
        }
    }

    return 0;
}
